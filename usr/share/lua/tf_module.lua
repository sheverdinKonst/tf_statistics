#!/usr/bin/lua

---
--- Generated by Luanalysis
--- Created by sheverdin.
--- DateTime: 2/15/24 1:24 PM


-- print("tfortis module Ver 1.0")

local tf_module = {}
local dkjson = require("dkjson")
--tf_module.uci = require("luci.model.uci").cursor()

local errorList = {
    "error >>> Command not found",
    "error >>> Value not found"
}

tf_module.ubusList =
{
    cmd_ubus    = "ubus call uci ",
    cmd_changes = "changes ",
    cmd_revert  = "revert ",
    cmd_reload  = "reload_config ",
    cmd_get     = "get ",
    cmd_config  = "\"config\":\"",
    cmd_section = "\",\"section\":\"",
    cmd_option  = "\",\"option\":\"",
    cmd_prefix  = "\'{",
    cmd_suffix  = "\"}\'",
}

tf_module.stp_cmdList = {
    get_mstpdConfig = "ubus call uci get \'{\"config\":\"mstpd\"}\'",
    get_netConfig   = "ubus call uci get \'{\"config\":\"network\"}\'"
}

function runCommand(command)
    local handle = io.popen(command)
    local result = handle:read("*a")
    handle:close()
    --print(result)
    return result
end

function getJsonTable(ubusCmd)
    local ubusRes = runCommand(ubusCmd)
    local jsonData = dkjson.decode(ubusRes, 1)
    return jsonData
end

function printList(pList)
    for k, v in pairs(pList) do
        if (k == nil) then
            print("key = nill")
        elseif type(k) == "table" then
            print("key is table")
        else
            io.write("key = ", tostring(k), "\n")
        end
        if (v == nil) then
            print("value = nill")
        elseif type(v) == "table" then
            print("value is table")
        else
            io.write("value = ", tostring(v), "\n")
        end
    end
end

function tf_module.getUbusDataByName(name)
    local ubus_cmd = "ubus call hw_sensor getStatus '{\"param\":\"" .. name .. "\"}'"
    local jsonInfo = getJsonTable(ubus_cmd)
    return jsonInfo
end

function tf_module.executeCommand(command)
    local res = runCommand(command)
    return res
end

function tf_module.collectJsonTable(ubusCmd)
    local jsonTable = getJsonTable(ubusCmd)
    return jsonTable
end

function tf_module.decodeJson(jsonData)
    local jsonData = dkjson.decode(jsonData, 1)
    return jsonData
end

function tf_module.getPortList(config, arg1, arg2)
    local configSwitch  = config[arg1]
    local portList      = configSwitch[arg2]
    -- printList(portList)
    return portList
end

function tf_module.validateParam(argc, argv)
    local errorCode = 0
    for i = 1, argc  do
        if argv[i] == nil then
            io.write(errorList[i], "\n")
            errorCode = tonumber(i)
        end
    end
    return errorCode;
end

function tf_module.changes(cmd_list)
    local changes_ubus_cmd = cmd_list.cmd_ubus .. cmd_list.cmd_changes
    local changes = getJsonTable(changes_ubus_cmd)
    local count = 1
    local configList = {}
    io.write("Changes: \n")
    for key, section in pairs(changes["changes"]) do
        io.write("\t>> ", key, ":\n")
        count = 1
        if section ~= nil and type(section) == "table" then
            table.insert(configList, key)
            for _, arr1 in pairs(section) do
                --print(count .. "  -----------------------------------")
                local changeMsg = "\t\t"
                changeMsg = changeMsg .. tostring(count) .. "\t"
                count = count + 1
                if arr1 ~= nil and type(arr1) == "table" then
                    for _, value in pairs(arr1) do
                        --print("value = ", value)
                        changeMsg = changeMsg .. value .. "\t"
                    end
                    io.write(changeMsg, "\n")
                end
            end
        end
    end
    return configList
end

function tf_module.uci_delete(optionlist, start, stop)
    local error = 1
    for opt_index = start, stop  do
        print("del option = " .. optionlist[opt_index])
        tf_module.uci:delete("network", "switch", optionlist[opt_index])
        error = 0
    end
    return error
end

function tf_module.checkPortRange(range)

    local result = {}
    if (range == "all") then
        result[1] = 0
        result[2] = 0
        result[3] = "all"
    elseif (range == "switch") then
        result[1] = 0
        result[2] = 0
        result[3] = "switch"
    else
        for value in string.gmatch(range, "[^-]+") do
            value = tonumber(value)
            table.insert(result, value)
            result[3] = "range"
        end

        if result[2] == nil then
            result[2] = result[1]
            result[3] = "range"
        end
        if result[1] > result[2] then
            result = nil
            io.write("error >> port range is wrong\n")
        end
    end
    return result
end

function tf_module.getPort(portStr)
    port = {}
    local portNumber = 0
    local state = "untagged"

    local portStr_1 = tostring(portStr)
    if string.find(portStr, ":t") then
        local str, num = portStr_1:match("(%w+)(%d+):(%a+)")
        portNumber = tonumber(num)
        state = "tagged"
    else
        local str, num = portStr_1:match("(%a+)(%d+)")
        portNumber = tonumber(num)
    end
    port.state      = state
    port.portNumber = portNumber
    return port
end

function tf_module.isPrintPortRange(portRange, port)
    local isPrint = 0
    if portRange[3] == "all" then
        isPrint = 1
    elseif  portRange[3] == "range" then
        local portMin = tonumber(portRange[1])
        local portMax = tonumber(portRange[2])
        if port >= portMin and port <= portMax then
            isPrint = 1
        end
    end
    return isPrint
end


function tf_module.get_hour_minutes(time_str)

    local time_H_M = {}
    local count = 1

    for part in string.gmatch(time_str, "([^:]+)") do
        print("count = " .. count)
        if count == 1 then
            local hour = tonumber(part)
            if hour > 24 or hour < 0 then
                part = nil
            end
        elseif count == 2 then
            local min = tonumber(part)
            if min > 60 or min < 0 then
                part = nil
            end
        end
        count = count + 1
        table.insert(time_H_M, part)
    end
    return time_H_M
end

return tf_module
